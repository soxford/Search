package search;

import java.util.HashMap;
import java.util.Map;

/**
 * An implementation of the Uniform Cost Graph Search Algorithm which always provides a minimum cost solution
 * @author Simon Campbell <simonhmcampbell@gmail.com>
 */
public class UniformCostGraphSearch extends GraphSearch {

	private Map<State,Integer> discoveredMinimumLengthRoute;

	public UniformCostGraphSearch(NodeFunction nodeFunction) {
		this(new BestFirstFrontier(nodeFunction));
	}
	
	private UniformCostGraphSearch(EditableFrontier frontier){
		super(frontier);
		discoveredMinimumLengthRoute = new HashMap<State,Integer>();
	}

	@Override
	protected void initializeSearch(State root) {
		frontier.clear();
		//set frontier to {{node(initial state, empty path)}}
		Node rootNode = new Node(null, null, root);
		frontier.add(rootNode);
		lastSearchNodeCount = 1; //initialize node count
		
		//set the discovered route lengths to include the root
		discoveredMinimumLengthRoute.clear();
		discoveredMinimumLengthRoute.put(root, rootNode.pathCost);
		
		//set discovered set to include the root
		discoveredButNotExploredSet.clear();
		discoveredButNotExploredSet.add(root);

		//set explored_set to an empty set (of states)
		exploredSet.clear();		
	}

	//Updates the search sets once we have checked whether the given state is a goal to reflect that we have explored the state
	@Override
	protected void updateSearchSets(State state) {
		exploredSet.add(state);
		discoveredButNotExploredSet.remove(state);		
	}

	//expands all possible actions and  a) if  the state has not been explored or discovered before add resulting nodes to the frontier and mark the state as discovered and record the path length
	//or else b) if the state has been discoveredButNotExplored and the new node gives a shorter route to the state then replace the node on the frontier that has the state
	//explored states must have already have had their minimum distance's found as the Uniform Cost Search algorithm explores states in order of their total minimum cost from the root state
	@Override
	protected void expandState(Node nextCandidate) {
		for(Action a: nextCandidate.state.getApplicableActions()){
			State nextState = nextCandidate.state.getActionResult(a);
			Node nextNode = new Node(nextCandidate, a, nextState);
			lastSearchNodeCount++; //keep count of nodes generated by the search

			if(!exploredSet.contains(nextState) && !discoveredButNotExploredSet.contains(nextState)){
				frontier.add(nextNode);
				discoveredButNotExploredSet.add(nextState); //update this tracking set
				discoveredMinimumLengthRoute.put(nextState, nextNode.pathCost);
			} else if ( discoveredButNotExploredSet.contains(nextState) && (nextNode.pathCost < discoveredMinimumLengthRoute.get(nextState)) ){
				//cast to EditableFrontier is fine as the constructor ensures the frontier is of this type
				((EditableFrontier) frontier).remove(nextState);
				frontier.add(nextNode);
				discoveredMinimumLengthRoute.put(nextState, nextNode.pathCost);
			}
		}		
	}
}
