package search;

import java.util.HashSet;
import java.util.Set;
/**
 * An implementation of the Graph Search algorithm. 
 * This avoids repeated exploration of the same states, and avoids repeated copies of the same state being included on the frontier.
 * @author Simon Campbell <simonhmcampbell@gmail.com>
 *
 */
public class GraphSearch extends FrontierSearch {
	protected Set<State> exploredSet;
	protected Set<State> discoveredButNotExploredSet = new HashSet<State>();


	public GraphSearch(Frontier frontier) {
		super(frontier);
		exploredSet = new HashSet<State>();
		discoveredButNotExploredSet = new HashSet<State>();
	}

	@Override
	protected void initializeSearch(State root) {
		frontier.clear();
		//set frontier to {{node(initial state, empty path)}}
		frontier.add(new Node(null, null, root));
		lastSearchNodeCount = 1; //initialize node count

		//set discovered set to include the root
		discoveredButNotExploredSet.clear();
		discoveredButNotExploredSet.add(root);

		//set explored_set to an empty set (of states)
		exploredSet.clear();		
	}

	//Updates the search sets once we have checked whether the given state is a goal
	@Override
	protected void updateSearchSets(State state) {
		exploredSet.add(state);
		discoveredButNotExploredSet.remove(state);		
	}

	//expands all possible actions and add resulting nodes to the frontier if the state has not been explored or discovered before and mark the state as discovered
	@Override
	protected void expandState(Node nextCandidate) {
		for(Action a: nextCandidate.state.getApplicableActions()){
			State nextState = nextCandidate.state.getActionResult(a);
			if(!exploredSet.contains(nextState) && !discoveredButNotExploredSet.contains(nextState)){
				frontier.add(new Node(nextCandidate, a, nextState));
				lastSearchNodeCount++; //keep count of nodes generated by the search
				discoveredButNotExploredSet.add(nextState); //update this tracking set
			}
		}		
	}



}
