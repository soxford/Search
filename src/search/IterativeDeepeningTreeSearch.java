package search;

import java.util.Set;

/**
 * Implementation of Iterative Deepening Search which loops depth first search to a depth limit before incrementing the depth limit and searching again for a solution.
 * @author Simon Campbell <simonhmcampbell@gmail.com>
 *
 */
public class IterativeDeepeningTreeSearch implements Search {
	protected final DepthFirstFrontier frontier = new DepthFirstFrontier();
	private int lastSearchNodeCount = -1;

	public IterativeDeepeningTreeSearch() {
	}

	@Override
	public Node findSolution(State root, GoalTest goalTest) {
		//validate input
		if(root == null || goalTest == null){
			throw new IllegalArgumentException();
		}

		this.lastSearchNodeCount = 0;
		boolean bottomFound = true;
		for(int maxDepth = 1; ; maxDepth++) {
			//set frontier to {{node(initial state, empty path)}}
			frontier.clear();//restart search from root
			frontier.add(new DepthNode(null, null, root, 0));
			this.lastSearchNodeCount++;
			//search frontier until empty
			while(!frontier.isEmpty()){
				//find next candidate
				DepthNode nextCandidate = (DepthNode) frontier.remove();
				//check if the candidate is a solution
				if(goalTest.isGoal(nextCandidate.state)){
					return nextCandidate;
				} else {	// if not then expand all possible actions and add resulting nodes to the frontier
					for(Action a: nextCandidate.state.getApplicableActions()){
						if (maxDepth < nextCandidate.depth + 1){ //check if we are beyond the maxDepth if we look at the next states and if so don't add them to the frontier
							bottomFound = false; //indicate that there was further to go so we should increment max depth on next search
							break; //this loop is too deep so skip it
						} else {
							frontier.add(new DepthNode(nextCandidate, a, nextCandidate.state.getActionResult(a), nextCandidate.depth+1));
							this.lastSearchNodeCount++; //keep count of nodes generated by the search
						}
					}
				}
			}
			if(bottomFound){ //if we found the bottom of the tree but no solution then we should not search again we need to break the loop and return null
				break;
			}
		}
		//if no goal is found then return null
		return null;
	}

	@Override
	public Node findSolution(State root, InferenceGoalTest inferenceGoalTest) {
		//validate input
		if(root == null || inferenceGoalTest == null){
			throw new IllegalArgumentException();
		}
		this.lastSearchNodeCount = 0;
		boolean bottomFound = true;
		for(int maxDepth = 1; ; maxDepth++) {
			//set frontier to {{node(initial state, empty path)}}
			frontier.clear();//restart search from root
			frontier.add(new DepthNode(null, null, root, 0));
			this.lastSearchNodeCount++;
			//search frontier until empty
			while(!frontier.isEmpty()){
				//find next candidate
				DepthNode nextCandidate = (DepthNode) frontier.remove();
				//check if the candidate is a solution
				if(inferenceGoalTest.isGoal(nextCandidate.state)){
					return nextCandidate;
				} else if(inferenceGoalTest.isViable(nextCandidate.state)){	// if not a goal then check viability and expand all possible actions and add resulting nodes to the frontier
					for(Action a: nextCandidate.state.getApplicableActions()){
						if (maxDepth < nextCandidate.depth + 1){ //check if we are beyond the maxDepth if we look at the next states and if so don't add them to the frontier
							bottomFound = false; //indicate that there was further to go so we should increment max depth on next search
							break; //this loop is too deep so skip it
						} else {
							frontier.add(new DepthNode(nextCandidate, a, nextCandidate.state.getActionResult(a), nextCandidate.depth+1));
							this.lastSearchNodeCount++; //keep count of nodes generated by the search
						}
					}
				}
			}
			if(bottomFound){ //if we found the bottom of the tree but no solution then we should not search again we need to break the loop and return null
				break;
			}
		}
		//if no goal is found then return null
		return null;
	}

	@Override
	public int getLastSearchNodeCount() {
		return lastSearchNodeCount;
	}


	private static class DepthNode extends Node{
		protected int depth;
		public DepthNode(Node parent, Action action, State state, int depth) {
			super(parent, action, state);
			this.depth = depth;
		}

	}


	@Override
	public Set<Node> findAllSolutions(State root, GoalTest goalTest,
			PathConstraint pathConstraint) {
		throw new UnsupportedOperationException();
	}

}
